# **第1章 Redis介绍**

Redis：全称为Remote Dictionary Server（远程数据服务）

是由 Salvatore Sanfilippo 用C语言开发的一款开源的、基于内存可持久化的日志型、高性能的键值对存储数据库。支持的Value类型很多，包括String 、List、 Set、 Sorted Set和Hash等

提供多种语言的API (JAVA，C# 等 )

### **1.1 Redis用途**

​	redis在开发中最多的用途就是做数据缓存，当并发量大的时候，为了缓解DBMS的压力，使用redis作为缓存，通过内存读取数据优化数据查询速度和缓解DBMS压力。

 当DBMS中数据进行修改时，会产生缓存与DBMS之间数据一致性问题。

### **1.2、缓存数据分类**

#### **1.2.1 实时同步数据**

​		要求缓存中数据必须与DB中数据保持一致。

​		**实现方式：**当DB中数据进行更新时，就会立即删除缓存中对应的数据。

#### **1.2.2 阶段性同步数据**

​		没必要必须与DB保持一致，大差不差即可。

​		**实现方式：**为缓存数据添加过期时长属性。

![缓存与DBMS的关系](C:\Users\56314\Desktop\学习笔记二\Learn-Project\学习笔记\Redis学习笔记\img\缓存与DBMS的关系.png)

​		缓存层数据并不是在第一个用户访问时进行写入，而是服务器启动后warmup（预热）过程时，将基础性的数据写入到缓存中，例如阶段性同步数据。

### **1.3、Redis的高性能特性**

​		能够做缓存的技术、中间件很多，例如Mybatis自带的二级缓存、Memched等。但是在生产中做缓存的产品几乎都会选择Redis，因为它有很多其他产品不具备的特性。

​		①**性能极高**：Redis  读速度可达11w次/s  写速度可达8w次/s。

​							（1）Redis所有操作都是在内存中发生。（其他可能需要将数据先从硬盘读写到内存中）

​							（2）Redis是用C语言开发的。（在高级开发语言中，和硬件最接近的就是C语言）

​							（3）Redis源码非常精细。（集性能与优雅于一身。)    [redis源码](https://github.com/redis/redis)

​		②**简单稳定**：源码少，早期版本只有2w行左右，从3.0开始，增加了集群功能，代码变为了5w行左右。（相比sqlite15w行，redis仅为1/3左右。） 代码量少，便于加载和阅读。

​		③**持久化**： Redis内存中的数据可以进行持久化，其中两种方式：RDB和AOF。

​		④**高可用集群**：redis提供了高可用的主从集群功能，可以确保系统的安全性。

​		⑤**丰富的数据类型**：redis是一个key-value存储系统，支持的value类型很多：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)等，还有BitMap、HypeLogLog、Geospatial类型。

​		BitMap：一般用于大数据的二值性统计。例如boolen类型业务数据，打卡没打卡 图像黑的还是白的。

​		HypeLogLog：（Hypelog Log）超级日志记录，对数据量超级大的日志进行去重统计。例如PV统计、UV统计等。 [PV统计、UV统计](https://zhidao.baidu.com/question/581152238.html)

​		Geospatial：地理位置，主要用于地理位置的相关计算。例如钉钉打卡。

​		⑥**强大的功能**：数据类型多，功能自然也强大。例如 可以设置缓存数据的过期时长、发布订阅、简单的事务功能、支持Lua脚本扩展等。

​		⑦**客户端语言广泛**：redis提供了简单的Tcp通信协议，编程语言可以方便的接入redis，因此有很多开源社区、公司等开发出了很多语言的redis客户端。

​		⑧**支持ACL权限控制**：在redis6之前，权限控制比较笨拙，从redis6开始，引入了ACL模块，可以为不同用户定制不同权限。

​			ACL，Access ControlList，访问控制列表，是一种细粒度的权限管理策略，可以针对任意用户与组进行权限控制。目前大多数Unix系统与Linux 2.6版本已经支持ACL了。Zookeeper早已支持ACL了。

​		Unix与Linux系统默认使用的是UGO（User、Group、Other）权限控制策略，其实是一种粗粒度的权限管理策略。

​		⑨**支持多线程IO模型**：redis在6版本之前是单线程模型，从6开始支持多线程模型。

### 	**1.4、Redis的IO模型**

​			Redis处理客户端请求所采用的处理架构，称为Redis的IO模型，不同版本的Redis采用的IO模型时不同的。

#### **1.4.1 单线程模型**

​	对于Redis 3.0及其以前版本，Redis的IO模型是 纯粹的单线程模型。 即所有客户端的请求全部由一个线程处理。 这里的客户端指的是web服务器。

​		![](C:\Users\56314\Desktop\学习笔记二\Learn-Project\学习笔记\Redis学习笔记\img\Redis的单线程模型示意图.jpg)

​	单线程采用**多路复用技术**。

​	对于多路复用器的**多路选择算法**常见的有三种：select模型、poll模型、epoll模型。

​	select底层为数组，poll底层为链表 这两个模型算法一样。

​	**poll模型的选择算法**：采用的是轮询算法。该模型对客户端的就绪处理是有延迟的。

​	**epoll 模型的选择算法**：采用回调方式。根据就绪事件发生后的处理方式不同，又可分为LT模型与ET模型。

​	在单线程模型 qps 8-10w 

​	客户端提出的连接请求 关闭请求 读写请求 都在内存中处理，很快。

​	多线程要考虑切换线程问题 数据加锁解锁问题  此时单线程会比多线程性能高。

#### **1.4.2 混合线程模型**

​	例如我们需要将缓存中的数据持久化 ，此时和用户相应请求没有关系，此时Thread会复刻出一些sub-thread，这些子线程处理的是redis内部的请求，处理后就会消除。

#### **1.4.3 多线程模型**

​		单线程性能很强悍，为什么还要发展多线程模型？

​		内存的响应时长（RT）是100ns  理论redis每秒处理的读写请求数量可以达到  1s/100/ns=10^9ns/100ns=10^7=1kw次。

​		实际上，redis每秒可以处理8w-11w的读写请求。

​		单线程限制了实际的性能。

![](C:\Users\56314\Desktop\学习笔记二\Learn-Project\学习笔记\Redis学习笔记\img\Redis的多线程模式.png)

​        多线程事件分发器，负载均衡，由IO解析并放入任务队列，交给主线程处理。这样不需要考虑线程安全问题，不需要考虑事务控制问题，也无需考虑LPUSH/LPOP 等命令执行顺序问题。

#### 1.4.4 线程模型优缺点总结

|            | 优点                                                         | 缺点                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单线程模型 | 可维护性高，性能高，不存在并发读写情况，所以不存在执行顺序的不确定性，不存在线程的开销，不存在死锁问题，不存在为了数据安全进行加锁/解锁开销 | 性能会受到影响，且由于单线程只能使用一个处理器，处理器资源会浪费。 |
| 多线程模型 | 结合了多线程与单线程的优点，避开了所有的不足。               | 并不是传统意义上的多线程模型，而是混合模型（真正处理业务的线程仍是单线程），所以对性能还是有影响的。 |

