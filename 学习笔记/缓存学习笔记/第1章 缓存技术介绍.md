# **缓存技术**

​	缓存就是数据交换的缓冲区（称作Cache），是存贮数据（使用频繁的数据）的临时地方。当用户查询数据，首先在缓存中寻找，如果找到了则直接执行。如果找不到，则去数据库中查找。

​	缓存的本质就是用空间换时间，牺牲数据的实时性，以服务器内存中的数据暂时代替从数据库读取最新的数据，减少数据库IO，减轻服务器压力，减少网络延迟，加快页面打开速度。

### **1.1 常见的缓存种类**

**常见的缓存种类有**：文件缓存、浏览器缓存、数据库缓存、Web应用层缓存、服务器缓存等。

**文件缓存**：文件缓存是把一些需要高速存取的变量缓存在内存中。模板引擎用的就是文件缓存机制，把动态代码编译成静态文件放入硬盘，不用每次访问都编译，直接读出即可。

**浏览器缓存**：浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果在浏览过程中前进或后退时访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显示。

**数据库缓存**：常用的缓存方案有Memcached、Redis等。把经常需要从数据库查询的数据、或经常更新的数据放入到缓存中，这样下次查询时，直接从缓存直接返回，减轻数据库压力，提升数据库性能。

**Web应用层缓存**：应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据、页面、图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。

**服务器缓存**：包括**代理服务器缓存**和**CDN缓存**。

**代理服务器缓存**：代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后(比如权限验证，缓存匹配等)，再将请求转发到源服务器。
代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少响应时间和带宽使用方面很有效，同一个副本会被重用多次。

**CDN缓存**：也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。
虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器。

### **1.2 缓存的优缺点**

​	**优点**：

​	**读取速度**：缓存最直接的作用就是可以加快读取速度,存在于内存中的缓存读取速度要远高于磁盘

​	**降低数据库压力**：数据库能承受的并发量往往比较有限,使用缓存命中后直接返回有助于降低SQL语句执行次数

​	**缺点**：

​	**数据不一致**： 由于缓存更新策略的原因,无法保证数据库和缓存中的数据一致性

​	**代码量增加**：代码中需要对缓存进行额外处理

### **1.3 Redis作为缓存的使用**

Redis作为缓存的使用很简单，只有读取和更新。

**读取**：

1.读取Redis中对应的Key

2.有缓存直接返回，否则读取数据库

3.数据库读出后写入 Redis ，并返回数据

**更新**：

1.更新数据库

2.删除 Redis 对应key

**流程**：

![读取与更新流程](C:\Users\56314\Desktop\学习笔记\缓存学习笔记\img\读取与更新流程.png)



**缓存更新时**：

​	有 `删除缓存，更新数据库`、`更新数据库，删除缓存`、`更新缓存，更新数据库`、`更新数据库，更新缓存` 这四种方式可选。

| \        | 先数据库               | 先缓存                |
| -------- | ---------------------- | --------------------- |
| 更新缓存 | ① set DB<br/>set cache | ②set cache<br/>set DB |
| 删除缓存 | ③set DB<br/>del cache  | ④del cache<br/>set DB |

① 和 ② 更新缓存

不论缓存和数据库的操作顺序，更新缓存都会面临相同的问题，这里就把 ① 和 ② 放一起写了。

这里以先更新数据库，再更新缓存为例，考虑以下场景：

有两个并发的写请求，一个将键`a`的值设置为 1 ，另一个设置为 2 时。由于两个写请求的处理顺序不确定，可能出现下图中的情况，导致最终缓存和数据库不一致。

同理，将缓存和数据库的操作顺序换过来也会面临一样的情况。

![更新缓存](C:\Users\56314\Desktop\学习笔记\缓存学习笔记\img\更新缓存①和②.jpg)

③ 最后也就是实际推荐的方式，先更新数据库，再删除缓存 。

使用该方式并不意味着万无一失，与上一种方法类似，在一读一写的情形下，也有可能发生数据的不一致。

![更新缓存③](C:\Users\56314\Desktop\学习笔记\缓存学习笔记\img\更新缓存③.jpg)

④ 与更新缓存不同，对于先删除缓存的情况，考虑存在并发的读和写请求的场景。

写请求先将键a对应的缓存删除，这时发生读取会导致无法命中缓存，将会从数据库中读出旧的数据写回缓存中，最后写请求将新的值写入数据库，导致不一致

![更新缓存④](C:\Users\56314\Desktop\学习笔记\缓存学习笔记\img\更新缓存④.png)

综上，都会出现数据不一致的问题。

​	想想在数据库内部是如何保证一致性的，把这里的数据库和缓存看做是两张表，在同一个事务中更新两张表时，会对被修改部分加写锁，阻塞其他事务对被修改数据的读写。

​	类似的，数据库和缓存之间的一致性也可以通过加锁来保证。但是这一方面提高了编码难度，另一方面由于加锁阻塞读写，与使用缓存提高读取效率的初衷背道而驰，并不适用。

### **1.4 常见得缓存问题**

**问题一：数据不一致**

​	一旦出现数据不一致问题，缓存中的脏数据就会一致保留，被反复读取。

​	为此，需要给缓存设置一个 **过期时间** 来避免脏数据一直保留，以在缓存过期后重新获取最新的正确数据。实现 **最终一致** 。

**问题二：缓存穿透**

​		当出现代码异常、爬虫遍历或者拒绝服务攻击时，可能出现大量访问缓存中不存在数据的请求。这时，缓存总是无法命中，所有请求都发到数据库上，引起缓存穿透的问题。

1. 缓存空值	

​		将 **Null** 作为一个特殊的值（比如字符串"null"）缓存下来，命中后也作为一个正常的值返回，可以避免数据库查询。

​		但是这种方法缺点在于，即使缓存空值也会占用内存，所以空值应设置一个较短的过期时间，避免占用过多内存。

2. 使用布隆过滤器

​		使用布隆过滤器可以让所有存在的数据以及少量的不存在数据通过，可以有效的避免缓存穿透问题。

​		缺点在于：布隆过滤器只有两个功能：添加和查询是否存在。不能进行删除，所以添加过的数据被删除后仍然会被放行，只能通过定期重建过滤器来避免。

**问题三：缓存击穿**

​		为了解决数据不一致的问题，上面的 [问题1](#问题1：数据不一致) 中给出了设置过期时间这个办法来实现最终一致性。但也因为这个过期时间，又引入了新的问题。

​		对于需要被高频访问的热点数据（比如明星的微博），会有源源不断的大量读请求。正常情况下，这些请求命中缓存直接返回，不会产生什么影响。

​		但是在缓存过期的时候，需要重新从数据库中读取数据写回缓存。由于这个操作并不能在一瞬间完成，所以在数据写回缓存之前的一段时间里，所有请求都会发到数据库上，引起一瞬间的负载过高。

解决方案：

1.排他锁

使用排他锁，同一时间只有一个线程去读取数据库，其他未获取锁的进行重试，直到数据写回缓存，将锁释放。

2. 不设置过期时间

对热点数据不设置过期时间，而是采用定时更新缓存等其他方式保证一致性。

### **总结**

综上所述，使用缓存可以有效降低数据库压力，提高系统的吞吐量，但也会带来一段时间内的数据不一致等问题。总体来说适用于读多写少、高吞吐量、能够转化为键值对格式、一定程度上容忍数据不一致的的场景。

以下场景需要慎用：

​	1.访问量低，数据库完全可以承受，不需要引入缓存带来额外的复杂性

​	2.数据一致性要求严格，比如涉及到资金的场景

​	3.读得少写得多，体现不出来缓存的优势，反而需要很多额外的删除缓存操作
